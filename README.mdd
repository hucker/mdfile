
# `MDFile` Overview
A utility that dynamically imports content from external files or commands into your Markdown documents. 
Perfect for keeping code samples, data, and command outputs in sync with your documentation.

MDFile supports directly copying data into Markdown files using the following format:

<!-- ignore -->
```markdown
# My Project - {{$meta.mdfile.version}}

Check out this function:

{{file example.py}}

Files used in this project:
{{process ls -a}}

 
Example Run:
{{shell python example.py}}
```
<!-- ignore end -->

After running `mdfile`,  you would have where each of the {{}} macros are expanded into the file.

````markdown
# My Project - 0.1.0

Check out this function:

```python
def hello():
    print("hello world")
    
```

Files used in this project:
```text
mdfile.py __init__.py
```

Example Run:
```bash
>> python example.py
hello world
````

`mdfile` is able to convert CSV files to Markdown tables as well as pretty print JSON files. Most
file inclusions will autodetect the format based on the file extension to enable browsers to 
syntax highlight as needed.

## Key Features

- **Multiple Import Methods**: Import files directly or capture command outputs
- **Smart Configuration** Config from `pyprject.toml`, `environment`, `mdfile.json`.
- **Smart Formatting**: Automatically applies correct syntax highlighting based on file extension
- **Table Formatting**: Converts CSV data into well-formatted Markdown tables
- **JSON Prettification**: Properly formats and highlights inserted JSON data.
- **Direct Markdown Insertion**: Markdown files are imported directly.
- **Variable Expansion**: Environment and package metadata is available `{{$meta.version}}`
- **Package Metadata***: Package metadata is directly fa

## Quick Example

The following example shows how to use `mdfile` using the Markdown comment tags.  These tags allow you
to dynamically update a Markdown file in place since the tags remain after update AND the text between tags 
is ignored when the file is updated again.  This feature is useful, but can be dangerous if you delete
half of a tag pair.

**Source file (example.py):**
```python
def hello_world():
    return "Hello, world!"
```

**In your README.mdd:**

<!-- ignore     -->

```markdown
# My Project

Check out this function:
{{file example.py}}
```
<!-- ignore end -->

**After running `mdfile` README.md:**
````markdown
# My Project

Check out this function:

```python
def hello_world():
    return "Hello, world!"
 ```

````

To make Markdown with the output from the `cat factorial.py` shell command.  This can be difficult
to get just right depending on the tool you are trying to use to pipe data from because different
command line utilities behave differently when data is displayed in a tty vs. a pipe. In the example
below the `cat` command is used to copy the data into the Markdown file, but any command can be used.
Keep in mind that some tools act differently when they are generating data for a tty compared to 
when they are piping data into a file.

<!-- ignore -->
`{{process cat factorial.py}}`
<!-- ignore end -->

```text
def factorial(n:int):
    """Return factorial of n"""
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

## Overview
`MDFile` 'converts' different file types to properly formatted Markdown, supporting:
- Code files (.py, .java, .js, and many more)
- Multiple files can be displayed using file globs such as `<!--file *.py-->`.
- CSV files (with table formatting)
- JSON files (pretty printed,with syntax highlighting)
- Markdown files inserted inline.
- Text files (plain text conversion)
- Basic variable substitution.
- Supports Overwrite (<!-- file x.x->) syntax and insertion {{file}} syntax.


**USEFUL NOTE: Paths are relative to the file that you are processing, so if files are in other folders please
reference them to the Markdown file that you are reading from.**


## Installation

If you are interested in development you can just go to GitHub and clone the repository. 

``` bash
# Clone the repository
git clone https://github.com/hucker/mdfile.git
cd mdfile

# Install the package
pip install -e .
```

**RECOMMENDED INSTALLATION**
If you are just interested in using `mdfile` as a tool the very best way to do it
is to just install `uv` and run:

```shell
(.venv) chuck@Chucks-Mac-mini mdfile % uv tool install mdfile 
Resolved 9 packages in 20ms
Installed 9 packages in 10ms
 + click==8.2.1
 + markdown-it-py==4.0.0
 + mdfile==0.5.0
 + mdurl==0.1.2
 + pygments==2.19.2
 + rich==14.1.0
 + shellingham==1.5.4
 + typer==0.16.0
 + typing-extensions==4.14.1
Installed 1 executable: mdfile
```

And then test it:

```shell
 Usage: main.py [OPTIONS] [FILE_NAME]                                           
                                                                                
 Convert a file to Markdown using merged configuration.                         
                                                                                
                                                                                
╭─ Arguments ──────────────────────────────────────────────────────────────────╮
│   file_name      [FILE_NAME]  The file to convert to Markdown (required      │
│                               unless in config)                              │
│                               [default: None]                                │
╰──────────────────────────────────────────────────────────────────────────────╯
╭─ Options ────────────────────────────────────────────────────────────────────╮
│ --output        -o      TEXT  Output file or stdout [default: None]          │
│ --plain                       Output plain Markdown without Rich formatting  │
│ --version       -V            Show version                                   │
│ --no_json                     Disable loading mdfile.json                    │
│ --no_pyproject                Disable loading pyproject.toml                 │
│ --no_env                      Disable loading environment variables          │
│ --help                        Show this message and exit.                    │
╰──────────────────────────────────────────────────────────────────────────────╯
```

and you should be off and running using this as a tool to update Markdown files anywhere.

## Basic Usage


The basic command for converting files is:
``` bash
uvx mdfile [FILE_PATH] [OPTIONS]
```
If you don't specify a file, it defaults to `README.md`.
### Command Line Options
``` bash
# Convert a file and print to stdout
uvx mdfile README.md

# Disable automatic line breaks in CSV headers
uvx mdfile README.md --no-auto-break
```
## Examples
### CSV to Markdown Table Conversion
#### Original CSV File: `sales_data.csv`
``` 
Region,Q1 Sales,Q2 Sales,Q3 Sales,Q4 Sales,Total
North,125000,133000,158000,175000,591000
South,105000,130000,115000,163000,513000
East,143000,123000,132000,145000,543000
West,117000,142000,138000,162000,559000
Total,490000,528000,543000,645000,2206000
```
#### Markdown Document with Inclusion: `report.md`

<!-- ignore -->
``` markdown
# Quarterly Sales Report

## Regional Sales Data

Here's a breakdown of our quarterly sales by region:

<!--file "sales_data.csv"-->
<!--file end-->

As we can see from the data, Q4 had the strongest performance across all regions.
```
<!-- ignore end -->

#### After Running `MDFile`:
``` bash
uvx mdfile report.md --bold "Total" -o final_report.md
```

---

#### Resulting Markdown: `final_report.md`

# Quarterly Sales Report

## Regional Sales Data

Here's a breakdown of our quarterly sales by region:

| Region    | Q1 Sales   | Q2 Sales   | Q3 Sales   | Q4 Sales   | Total       |
|-----------|------------|------------|------------|------------|-------------|
| North     | 125000     | 133000     | 158000     | 175000     | 591000      |
| South     | 105000     | 130000     | 115000     | 163000     | 513000      |
| East      | 143000     | 123000     | 132000     | 145000     | 543000      |
| West      | 117000     | 142000     | 138000     | 162000     | 559000      |
| **Total** | **490000** | **528000** | **543000** | **645000** | **2206000** |


As we can see from the data, Q4 had the strongest performance across all regions.

---

### Including JSON Configuration

```json
{"name":"John Doe","age":30,"isStudent":false,"grades":[78,85,90],"address":{"street":"123 Main St","city":"New York","zip":"10001"}}
```

<!-- ignore -->
``` markdown
## Configuration

The default configuration is:

<!--file "path/to/config.json"-->
<!--file end-->
```
<!-- ignore end -->

The updated `README.md` file is shown below with the JSON pretty printed.

<!-- ignore -->

```` markdown
## Configuration

The default configuration is:

<!--file "path/to/config.json"-->
```json
{
    "name": "John Doe",
    "age": 30,
    "isStudent": false,
    "grades": [
        78,
        85,
        90
    ],
    "address": {
        "street": "123 Main St",
        "city": "New York",
        "zip": "10001"
    }
}
```
<!--file end-->
````
<!-- ignore end -->

## File Type Support
`MDFile` supports numerous file extensions allowing MarkDown to correctly syntax highlight:
- Python: `.py`, `.pyw`, `.pyx`, `.pyi`
- JavaScript: `.js`, `.mjs`, `.cjs`
- TypeScript: `.ts`, `.tsx`
- Java: `.java`
- C/C++: `.c`, `.h`, `.cpp`, `.cc`, `.hpp`
- Web: `.html`, `.htm`, `.css`, `.scss`
- Data: `.json`, `.yaml`, `.yml`, `.csv`
- Configuration: `.ini`, `.cfg`, `.conf`
- Shell: `.sh`, `.bash`, `.zsh`
- And lots more...

These file extensions map use the standard triple back tick text blocks available in Markdown.

## Options for CSV Files
When converting CSV files, you have additional options.
- `bold VALUE1,VALUE2,...` - Make specific columns bold in the table
- `auto-break` - Control automatic line breaks in CSV headers

These values may be set in `pyproject.toml`, `mdfile.json` and enviroment varaibles (if you are insane).

## Variable Substitution
`mdfile` supports a basic form of variable substitution that follows very simple replacement
rules.  You cannot nest names. At this time the `date` and `time` are available that indicated
when the tool was run. You may also pull variables directly from the environment, you can
pull metadata from any python package installed in the project and if you have specified an
`mdfile.json` dictionary you can pull any value from that file directly as if those variables were
defined at the top level and finally anything in the `pyprjoect.toml` files `[tool.mdfile]` is available.


<!-- ignore -->
| Variable                | Description                                                |
|-------------------------|------------------------------------------------------------|
| `{{$date}}`             | current date                                               |
| `{{$time}}`             | current time                                               |
| `{{$ENV.(VAR)}}`        | VAR pulled from Environment using os.env                   |
| `{{$meta.(pkg).(var)}}` | Package metadata variables like (e.g. meta.mdfile.version) |
!-- ignore end -->

* See `importlib.metadata.metadata` for full list of available variables.

These values are imported directly into the Markdown file with no special Markdown tags, just raw text
this allows you to have text such as:

<!-- ignore -->
```App **{{$name}}** version **{{$meta.mdfile.version}}** was created on {{$date}}```
<!-- ignore end -->

To get the text

App **mdfile** version **0.10.0** was created on 1/1/2024

Information from the `pyproject.toml` and `mdfile.json` can be read using "dotted" notation in
the event that data in thos files is nested.  So if your mdfile.json is

```json
{
  "var1": 12,
  "var2": {
    "name": "Chuck"
  }
}
```

You could write:
<!--ignore-->
`My name is {{$var2.name}}.`
<!--ignore end-->

to get:

`My name is Chuck`

## Environment Substitution

Environment variables may also be inserted into your Markdown files using the following notation:

<!-- ignore -->
```text
Root Project Directory = `{{ENV.PWD}}`
```
<!-- ignore end -->


```text
Root Project Directory = `/Users/chuck/Projects/mdfile/src/mdfile`
```

NOTE: `mdfile` aggressively attempts to block publishing API_KEYS into `readme` documents if you are noticing 
that ENV_API_KEY is not substituting into your readme, it is being blocked.  If you must (which you shouldn't)
you can give an API KEY a different variable name.  It is likely that won't work since GitHub knows how to
find the keys by looking at the key itself.

### Ignoring Stuff
It may happen that you do NOT want the tool to expand variables and modify the text in the README that you 
are updating. 

The solution to this is to have "ignore blocks".  These blocks are ignored by to tool and passed through
to the output. It isn't really possible to show the tags in raw markup or else the tool would remove them
or the Markdown tool would hide them as a comment. They are shown below with backslashes to "escape" the 
html comments characters. 

```text
 \<\!\-\- ignore \-\-\>
 \<\!\-\- ignore end \-\-\>
```

You should never/rarely need this tool unless you are explaining how to use the tools, and you don't
want transformations to occur, or you have a very unlikely collision.

### UVX
If you installed `mdfile` as a `uv` tool then you can run `mdfile` from anywhere using 
the `uvx` tool.

```bash
uvx mdfile ../README_template.md --output ../README.md
```

``` bash
uvx mdfile documentation.md -o updated_docs.md
```

## Disclaimer
This tool was made open source because it is somewhat useful as it grew features over time. It is
not a great example of how to write clean code since it grew organically in several projects. Don't
be too harsh judging the code.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request


## License
[MIT License](LICENSE)
